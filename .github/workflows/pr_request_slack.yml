name: PR Workflow

on:
  pull_request:
    types: [opened, review_requested]

jobs:
  add_label:
    runs-on: ubuntu-latest
    # PR이 처음 열렸을 때만 라벨 추가
    if: github.event.action == 'opened'
    steps:
      - uses: actions/checkout@v3

      - name: Add D-day label
        uses: naver/simple-labeler@latest
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          labels: "D-3"
          duplicate: "D-*"

  notify_reviewer:
    runs-on: ubuntu-latest
    # 리뷰어가 요청되었을 때만 실행하고, PR이 처음 열린 경우 라벨 추가 후 실행
    if: github.event.action == 'review_requested' || github.event.action == 'opened'
    needs: [add_label]
    steps:
      - uses: actions/checkout@v3

      - name: Get PR Info with Labels
        id: pr_info
        uses: actions/github-script@v6
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            const dDayLabel = pr.labels
              .find(label => label.name.startsWith('D-'))?.name || 'D-3';
            return JSON.stringify({ dDayLabel });

      - name: 리뷰어 목록 가져오기
        id: reviewers
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const workers = JSON.parse(fs.readFileSync('.github/workflows/reviewers.json'));
            const mentions = context.payload.pull_request.requested_reviewers.map((user) => {
              const login = user.login;
              return workers[login] || null;
            }).filter(id => id !== null);
            return JSON.stringify(mentions);

      - name: PR 리뷰어들에게 개별 DM 보내기
        if: steps.reviewers.outputs.result != '[]' # 리뷰어가 있을 때만 실행
        uses: actions/github-script@v6
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        with:
          script: |
            const https = require('https');
            const reviewers = JSON.parse('${{ steps.reviewers.outputs.result }}');
            const prInfo = JSON.parse('${{ steps.pr_info.outputs.result }}');

            for (const reviewer of reviewers) {
              const message = {
                channel: reviewer,
                text: "PR 리뷰 요청",
                blocks: [
                  {
                    type: "section",
                    text: {
                      type: "mrkdwn",
                      text: `<@${reviewer}>님 리뷰어로 할당되었습니다.\n • 제목: ${{ github.event.pull_request.title }}\n • 마감: ${prInfo.dDayLabel}\n • 링크: <${{ github.event.pull_request.html_url }}|리뷰하러 가기>`
                    }
                  }
                ]
              };

              const options = {
                hostname: 'slack.com',
                path: '/api/chat.postMessage',
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}`,
                  'Content-Type': 'application/json'
                }
              };

              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                  console.log('Slack response:', data);
                });
              });

              req.on('error', (error) => {
                console.error('Error:', error);
              });

              req.write(JSON.stringify(message));
              req.end();
            }
